#!/bin/bash
#set -x
source /opt/k8comp/k8comp.conf

k8comp_home=$k8comp_dir/bin
mapping=$k8comp_dir/extras/mapping

source $k8comp_home/usage

programname=$0
red="$(tput setaf 1)"
green="$(tput setaf 2)"
yellow="$(tput setaf 3)"

MAIN() {
  if [ $pull ]
  then
    git_pull_only
  else
    set_environments
    kube_vars
    set_file
    create_tmp
# replace main variables on the main temporary file
    replace_var
    replace_xvar
    replace_allvar
# replace the main variables if any are passed back on the main temp file from hiera
    replace_var
    external_files
    print_file
    clean
  fi
}

error() {
    echo -e "${red}[ ERROR ] - $@ $(tput sgr0)"
}

message_green() {
    echo -e "${green}$@ $(tput sgr0)"
}

message_yellow() {
    echo -e "${yellow}$@ $(tput sgr0)"
}

read_x_args() {
  while (($#)) && [[ $1 != -* ]];
  do args+=("$1");
    shift;
  done
}

while [ $# -gt 0 ]; do
# set the variable from input for all the arguments
  input+=("$1")
# set variables from input
  case "$1" in
    -p|--project)
      if [ -n "$2" ]; then
        project=$2
        hrp="project=${2}"
        hrall+="${hrp} "
        shift
      fi
    ;;
    -a|--application)
      if [ -n "$2" ]; then
        application=${2}
        hra="application=${2%%/*}"
        hrall+="${hra} "
        shift
      fi
    ;;
    -e|--environment)
      if [ -n "$2" ]; then
        environment=$2
        hre="environment=${2}"
        hrall+="${hre} "
        shift
      fi
    ;;
    -l|--location)
      if [ -n "$2" ]; then
        location=$2
        hrl="location=${2}"
        hrall+="${hrl} "
        shift
      fi
    ;;
    -b|--branch)
      if [ -n "$2" ]; then
        branch=$2
        hrb="branch=${2}"
        hrall+="${hrb} "
        shift
      fi
    ;;
    -x|--xtra)
      read_x_args "${@:2}"
    ;;
    pull|--pull)
      pull=true
    ;;
    -h|--help)
      usage
      exit 0
    ;;
  esac
  shift
done

# function used only to pull specific branches as environments
git_pull_only () {
  if [ $pull ] && [ ${projects_repo} ]
  then
    if set_environments
    then
      message_green "[ NOTICE ] - Successful pull ${branch:-${main_deployment_branch}} branch"
    fi
  else
    error "Projects repo not declared"
  fi
}

clone_git () {
  if ! grep -sq "$1" $projects_path/environments/${branch:-${main_deployment_branch}}/${2}/.git/config
  then
    rm -rf $projects_path/environments/${branch:-${main_deployment_branch}}/${2}
    if ! git clone --quiet $1 $projects_path/environments/${branch:-${main_deployment_branch}}/${2}
    then
      error "Error cloning $1"
      exit 1
    fi
  fi
  cd $projects_path/environments/${branch:-${main_deployment_branch}}/${2}
  git reset --hard HEAD --quiet
  git fetch --quiet --all
  git pull --quiet --all
  if ! git checkout ${branch:-${main_deployment_branch}} --quiet
  then
    error "Branch ${branch:-${main_deployment_branch}} not found"
    exit 1
  fi
}

# function used for environments based on branches
set_environments() {
  if [ "${k8comp_environments}" == "enabled" ] && [ "$auto_git_pull" == "true" ] || [ $pull ]
  then
    if [ -z $hieradata_repo ]
    then
      clone_git $projects_repo
    elif [ -n $hieradata_repo ]
    then
      clone_git $projects_repo projects
      clone_git $hieradata_repo hieradata
    fi
  fi
  if [[ "${k8comp_environments}" == "enabled" && -z ${branch} ]]
  then
    hrb="branch=${branch:-${main_deployment_branch}}"
    hrall+="${hrb} "
  fi
}

# the function will check the variables mapping and replace them in the deployment
# if the variables cannot be found the cmd values will be used
kube_vars(){
  for i in ${hrall[@]}
  do
    find_var=$(grep -vs '^#' $mapping/* | grep -h "^${i##*=}=")
# all variables form extras/mapping will be passed to hiera via mappings variable
    mappings+=($find_var)
    if [[ "${i%%=*}" == "project" ]]
    then
      if [ -z $find_var ]
      then
        h_project=$project
      else
        pvar=$find_var
        h_project=${pvar##*=}
      fi
    elif [[ "${i%%=*}" == "application" ]]
    then
      if [ -z $find_var ]
      then
        h_application=${application%%/*}
      else
        avar=$find_var
        h_application=${avar##*=}
      fi
    elif [[ "${i%%=*}" == "environment" ]]
    then
      if [ -z $find_var ]
      then
        h_environment=$environment
      else
        evar=$find_var
        h_environment=${evar##*=}
      fi
    elif [[ "${i%%=*}" == "location=" ]]
    then
      if [ -z $find_var ]
      then
        h_location=$location
      else
        lvar=$find_var
        h_location=${lvar##*=}
      fi
    fi
done
}

set_file() {
# if multiple environments are enabled set a variable with the new folder path
  if [ "${k8comp_environments}" == "enabled" ]
  then
    envs="environments/${branch:-${main_deployment_branch}}/projects"
    err1="or projects/${envs}"
  fi

  if [ -z $environment ]
  then
    err2="and no environment specified"
  fi

  err0="No deployment files found on projects/$project ${err1} ${err2}"

# if project, application and any other argument is declared
  if [[ "${input[@]}" =~ "p" && "${input[@]}" =~ "a" ]]
  then
# test if the application is a file or a folder

    if [ -f ${projects_path}/${envs}/${project}/${application}.* ]
    then
      xfile=${projects_path}/${envs}/${project}/${application}.*

    elif [ -d ${projects_path}/${envs}/${project}/${application} ]
    then
      xfolder=${projects_path}/${envs}/${project}/${application}
      xfile=${xfolder}/*
    else
      error $err0
      exit 1
    fi

# if project is not declared
elif [[ ! "${input[@]}" =~ "p" && "${input[@]}" =~ "a" ]]
 then
# test if the application is a file or a folder
  if [ -f ${projects_path}/${envs}/${application}.* ]
  then
    xfile=${projects_path}/${envs}/${application}.*
  elif [ -d ${projects_path}/${envs}/${application} ]
  then
    xfolder=${projects_path}/${envs}/${application}
    xfile=${xfolder}/*
  else
    error $err0
    exit 1
  fi
# if project and any other argument is declared other than application
  elif [[ "${input[@]}" =~ "p" ]]
  then
    if [ -f ${projects_path}/${envs}/${project}.* ]
    then
      xfile=${projects_path}/${envs}/${project}.*
    else
      error $err0
      exit 1
    fi
  fi

# test if either the file or the folder of the application exists
  for file in ${xfile}
  do
    if [ ! -d ${xfolder} ] || [ ! -f ${file} ]
    then
      error "${project} ${application} not found in projects folder"
      exit 1
    fi
  done
}

create_tmp() {
  tmp_file=$(mktemp /tmp/k8comp.XXXXXX)
# set the start of the file
  for eachfile in ${xfile}
  do
    if [[ "$(head -1 ${eachfile})" =~ "---" ]]
    then
      grep -v '^#' ${eachfile} >> ${tmp_file}
    else
      echo -e "\n---" >> ${tmp_file}
      grep -v '^#' ${eachfile} >> ${tmp_file}
    fi
  done
  echo " " >> ${tmp_file}
}

replace_var() {
  sed -i "s|%{project}|${h_project}|g" ${tmp_file}
  sed -i "s|%{application}|${h_application}|g" ${tmp_file}
  sed -i "s|%{environment}|${h_environment}|g" ${tmp_file}
  sed -i "s|%{location}|${h_location}|g" ${tmp_file}
}

replace_xvar() {
  for xvar in ${args[@]}
  do
# avoind any conflicts when the variable include = character
    xvar2=$(echo ${xvar} | cut -c $(($(echo ${xvar%%=*} | awk '{ print length }')+2))-)
    sed -i "s|%{${xvar%%=*}}|${xvar2}|g" ${tmp_file}
  done
}

add_multiline_var () {
ed ${1}  > /dev/null 2>&1 << __EOF__
${2}i
$(cat ${3})
.
wq
__EOF__
}

replace_allvar() {
  for variable in $(grep -o '\%{[a-z,A-Z,0-9,_,-]*\}' ${tmp_file} |sort |uniq |sed 's|[%{}]||g')
  do
    hr="${hiera_path}/hiera -c ${custom_hiera} ${variable} ${hrall[@]} ${mappings[@]}"
# Check if should fail on variable not found
    if [ "$($hr)" = "nil" ] || [ -z "$($hr)" ]
    then
    nf_var+="$variable "
      if [ "$var_fail_safe" == "true" ]
      then
        error "${variable} not found in hiera"
        clean
        exit 1
      else
# avoid nil value being added on the deployment file
        sed -i "s|%{${variable}}||g" ${tmp_file}
      fi

# if variable has more lines
    elif [[ "$($hr)" =~ '=>' ]]
    then
# counting the number of the same variable
      for each in $(grep -wn "%{${variable}}" ${tmp_file} | awk -F ':' '{print $1}')
      do
       variable_line_nr+="${each} "
      done
# for each variable in the files run a loop and replace the value
      for i in ${variable_line_nr[@]}
      do
# getting the new line of the variable
        var_line=$(grep -wn "%{${variable}}" ${tmp_file} | awk -F ':' '{print $1}' | head -1)
        var_file=$(mktemp /tmp/k8comp.XXXXXX)
        if [ ! -z ${var_line} ]
        then
          leading_spaces=$(sed -n ${var_line}p ${tmp_file} | awk -F"[ ]" '{for(i=1;i<=NF && ($i=="");i++);print i}')
          add_leading_spaces=$(seq -s' ' ${leading_spaces}|tr -d '[:digit:]')
          $hr -f yaml | tail -n +2 | sed -e "s/^/${add_leading_spaces}/" > $var_file
# delete line
          sed -i "${var_line}d" ${tmp_file}

          add_multiline_var ${tmp_file} ${var_line} ${var_file}

        fi
        if [ -f $var_file ]
        then
          rm -f $var_file
        fi
      done
    else
      sed -i "s|%{${variable}}|$($hr)|g" ${tmp_file}
    fi
  done
}

external_files() {
  urls=$(grep '^http' ${tmp_file})

  for u in ${urls}
  do
    sed -i "s|${u}||g" ${tmp_file}
    ext=$(curl -qs ${u})
    if [[ "${ext} | head -1" =~ "---" ]]
    then
      echo "${ext}" >> ${tmp_file}
    else
      echo -e "\n---" >> ${tmp_file}
      echo "${ext}" >> ${tmp_file}
    fi
  done
}

print_file() {
  # set notification variable
  notification="# NOTICE - Deployment from ${xfile}"
  border="######################"
  # print file on stdout
  cat ${tmp_file} | sed '/^$/d'
  # echo notification
  echo ${border}
  echo ""
  echo ${notification}
  if [ ! -z "${nf_var[@]}" ]
  then
    echo ""
    echo "# The following variables couldn't be retrieved from hiera: ${nf_var[@]}"
    echo ""
  fi
}

clean() {
  if [ -f ${tmp_file} ]
  then
    rm -f ${tmp_file}
  fi
}

MAIN
