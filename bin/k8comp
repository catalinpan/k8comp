#!/bin/bash

source /opt/k8comp/k8comp.conf

k8comp_home=$k8comp_dir/bin
mapping=$k8comp_dir/extras/mapping

#source $k8comp_dir/extras/repo.conf
source $k8comp_home/usage

programname=$0
red="$(tput setaf 1)"
green="$(tput setaf 2)"
yellow="$(tput setaf 3)"

MAIN() {
  set_environments
  kube_vars
  check_vars
  set_file
  create_tmp
  replace_var
  replace_xvar
  replace_allvar
  external_files
  print_file
  clean
}

error() {
    echo -e "${red}[ ERROR ] - $@ $(tput sgr0)"
}

message_green() {
    echo -e "${green} $@ $(tput sgr0)"
}

message_yellow() {
    echo -e "${yellow} $@ $(tput sgr0)"
}

read_x_args() {
  while (($#)) && [[ $1 != -* ]];
  do args+=("$1");
    shift;
  done
}

while [ $# -gt 0 ]; do
# set the variable from input for all the arguments
  input+=("$1")
# set variables from input
  case "$1" in
    -p|--project)
      if [ -n "$2" ]; then
        project=$2
        hrp="project=${2}"
        hrall+="${hrp} "
        shift
      else
        usage
        exit 1
      fi
    ;;
    -a|--application)
      if [ -n "$2" ]; then
        application=${2}
        hra="application=${2%%/*}"
        hrall+="${hra} "
        shift
      else
        usage
        exit 1
      fi
    ;;
    -e|--environment)
      if [ -n "$2" ]; then
        environment=$2
        hre="environment=${2}"
        hrall+="${hre} "
        shift
      fi
    ;;
    -l|--location)
      if [ -n "$2" ]; then
        location=$2
        hrl="location=${2}"
        hrall+="${hrl} "
        shift
      fi
    ;;
    -b|--branch)
      if [ -n "$2" ]; then
        branch=$2
        hrb="branch=${2}"
        hrall+="${hrb} "
        shift
      fi
    ;;
    -x|--xtra)
      read_x_args "${@:2}"
    ;;
    -h|--help)
      usage
      exit 0
    ;;
  esac
  shift
done

clone_git () {
  if ! grep -sq "$1" $projects_path/environments/${branch:-${main_deployment_branch}}/${2}/.git/config
  then
    rm -rf $projects_path/environments/${branch:-${main_deployment_branch}}/${2}
    git clone --quiet $1 $projects_path/environments/${branch:-${main_deployment_branch}}/${2}
  fi
  cd $projects_path/environments/${branch:-${main_deployment_branch}}/${2}
  git fetch --quiet --all
  git pull --quiet --all
  git reset --hard HEAD --quiet
  if ! git checkout ${branch:-${main_deployment_branch}} --quiet
  then
    error "Branch ${branch:-${main_deployment_branch}} not found"
    exit 1
  fi
}

set_environments() {
  if [[ "${k8comp_environments}" == "enabled" && "$auto_git_pull" == "true" ]]
  then
    if [ "$hieradata_repo" == "" ]
    then
      clone_git $projects_repo
    elif [ "$hieradata_repo" != "" ]
    then
      clone_git $projects_repo projects
      clone_git $hieradata_repo hieradata
    fi
    if [ "$branch" == "" ]
    then
      hrb="branch=${branch:-${main_deployment_branch}}"
      hrall+="${hrb} "
    fi
  fi
}

# the below function will check the variables mapping and replace them in the deployment
# if the variables cannot be found the cmd values will be used
kube_vars(){
  for i in ${hrall[@]}
  do
    find_var=$(grep -v '^#' $mapping/* | grep -h "^${i##*=}=")
    if [[ "${i%%=*}" == "project" ]]
    then
      if [ -z $find_var ]
      then
        h_project=$project
      else
        pvar=$find_var
        h_project=${pvar##*=}
      fi
    elif [[ "${i%%=*}" == "application" ]]
    then
      if [ -z $find_var ]
      then
        h_application=$application
      else
        avar=$find_var
        h_application=${avar##*=}
      fi
    elif [[ "${i%%=*}" == "environment" ]]
    then
      if [ -z $find_var ]
      then
        h_environment=$environment
      else
        evar=$find_var
        h_environment=${evar##*=}
      fi
    elif [[ "${i%%=*}" == "location=" ]]
    then
      if [ -z $find_var ]
      then
        h_location=$location
      else
        lvar=$find_var
        h_location=${lvar##*=}
      fi
    fi
done
}

# check if the required values are declared
check_vars() {
  if [ -z ${project} ]
  then
  	usage
  	exit 1
  fi
}

set_file() {
# if multiple environments are enabled set a variable with the new folder path
  if [ "${k8comp_environments}" == "enabled" ]
  then
    envs="environments/${branch:-${main_deployment_branch}}/projects"
    err1="or projects/${envs}"
  fi

  if [ -z $environment ]
  then
    err2="and no environment specified"
  fi

  err0="No deployment files found on projects/$project ${err1} ${err2}"

# if project, application and any other argument is declared
  if [[ "${input[@]}" =~ "p" && "${input[@]}" =~ "a" ]]
  then
# test if the application is a file or a folder

    if [ -f ${projects_path}/${envs}/${project}/${application}.* ]
    then
      xfile=${projects_path}/${envs}/${project}/${application}.*

    elif [ -d ${projects_path}/${envs}/${project}/${application} ]
    then
      xfolder=${projects_path}/${envs}/${project}/${application}
      xfile=${xfolder}/*

    elif [ -f ${projects_path}/${project}/${application}.* ]
    then
      xfile=${projects_path}/${project}/${application}.*

    elif [ -d ${projects_path}/${project}/${application} ]
    then
      xfolder=${projects_path}/${project}/${application}
      xfile=${xfolder}/*

    else
      error $err0
      exit 1
    fi
# if project and any other argument is declared other than application
  elif [[ "${input[@]}" =~ "p" ]]
  then
    if [ -f ${projects_path}/${envs}/${project}.* ]
    then
      xfile=${projects_path}/${envs}/${project}.*

    elif [ -f ${projects_path}/${project}.* ]
    then
      xfile=${projects_path}/${project}.*

    else
      error $err0
      exit 1
    fi
  fi

# test if either the file or the folder of the application exists
  for file in ${xfile}
  do
    if [ ! -d ${xfolder} ] || [ ! -f ${file} ]
    then
      error "${project} ${application} not found in projects folder"
      exit 1
    fi
  done
}

create_tmp() {
  tmp_file=$(mktemp /tmp/k8comp.XXXXXX)
# set the start of the file
  for eachfile in ${xfile}
  do
    if [[ "$(head -1 ${eachfile})" =~ "---" ]]
    then
      grep -v '^#' ${eachfile} >> ${tmp_file}
    else
      echo -e "\n---" >> ${tmp_file}
      grep -v '^#' ${eachfile} >> ${tmp_file}
    fi
  done
}

replace_var() {
  sed -i "s|%{project}|${h_project}|g" ${tmp_file}
  sed -i "s|%{application}|${h_application}|g" ${tmp_file}
  sed -i "s|%{environment}|${h_environment}|g" ${tmp_file}
  sed -i "s|%{location}|${h_location}|g" ${tmp_file}
}

replace_xvar() {
  for xvar in ${args[@]}
  do
# avoind any conflicts when the variable include = character
    xvar2=$(echo ${xvar} | cut -c $(($(echo ${xvar%%=*} | awk '{ print length }')+2))-)
    sed -i "s|%{${xvar%%=*}}|${xvar2}|g" ${tmp_file}
  done
}

add_multiline_var () {
ed ${1}  > /dev/null 2>&1 << END
${2}i
$(cat ${3})
.
wq
END
}

replace_allvar() {
  for variable in $(grep -o '\%{[a-z,A-Z,0-9,_,-]*\}' ${tmp_file} |sort |uniq |sed 's|[%{}]||g')
  do
    hr="${hiera_path}/hiera -c ${custom_hiera} ${variable} ${hrall[@]}"
# Check if should fail on variable not found
    if [ "$($hr)" = "nil" ] || [ "$($hr)" = "" ]
    then
    nf_var+="$variable "
      if [ "$var_fail_safe" == "true" ]
      then
        error "${variable} not found in hiera"
        clean
        exit 1
      else
# avoid nil value being added on the deployment file
        sed -i "s|%{${variable}}||g" ${tmp_file}
      fi

# if variable has more lines
    elif [[ "$($hr)" =~ "=>" ]]
    then
      variable_line_nr=$(grep -wn "%{${variable}}" ${tmp_file} | awk -F ':' '{print $1}')
      leading_spaces=$(sed -n ${variable_line_nr}p ${tmp_file} | awk -F"[ ]" '{for(i=1;i<=NF && ($i=="");i++);print i}')
      var_file=$(mktemp /tmp/k8comp.XXXXXX)
      add_leading_spaces=$(seq -s' ' ${leading_spaces}|tr -d '[:digit:]')
      $hr -f yaml | tail -n +2 | sed -e "s/^/${add_leading_spaces}/" > $var_file
      sed -i "${variable_line_nr}d" ${tmp_file}

      add_multiline_var ${tmp_file} ${variable_line_nr} ${var_file}

      if [ -f /tmp/k8comp.XXXXXX ]
      then
        rm -rf /tmp/k8comp.XXXXXX
      fi

    else
      sed -i "s|%{${variable}}|$($hr)|g" ${tmp_file}
    fi
  done
}

external_files() {
  urls=$(grep '^http' ${tmp_file})

  for u in ${urls}
  do
    sed -i "s|${u}||g" ${tmp_file}
    ext=$(curl -qs ${u})
    if [[ "${ext} | head -1" =~ "---" ]]
    then
      echo "${ext}" >> ${tmp_file}
    else
      echo -e "\n---" >> ${tmp_file}
      echo "${ext}" >> ${tmp_file}
    fi
  done
}

print_file() {
  # set notification variable
  notification="# NOTICE - Deployment from ${xfile}"
  border="######################"
  # print file on stdout
  cat ${tmp_file} | sed '/^$/d'
  # echo notification
  echo ${border}
  echo ""
  echo ${notification}
  if [ ! -z "${nf_var[@]}" ]
  then
    echo ""
    echo "# The following variables couldn't be retrieved from hiera: ${nf_var[@]}"
    echo ""
  fi
}

clean() {
  if [ -f ${tmp_file} ]
  then
    rm -rf ${tmp_file}
  fi
}

MAIN
